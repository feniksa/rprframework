#include "Plugin.h"
#include "Context.h"
#include "FrameBuffer.h"
#include "Scene.h"
#include "Camera.h"
#include "Shape.h"
#include "LightPoint.h"
#include "ContextUtils.h"
#include "FrameBufferSysmem.h"
#include "MaterialSystem.h"
#include "MaterialNode.h"
#include "math/mathutils.h"

#include "Environment.h" // <- generated by cmake
#include "StreamRedirector.h"
#include "CommonData.h"

#include <gtest/gtest.h>
#include <algorithm>
#include <filesystem>

using namespace rprf;
using namespace tests;


struct TestNorthstar : public ::testing::Test
{
	std::unique_ptr<Plugin> m_plugin;
	std::filesystem::path m_tempDir;
	std::filesystem::path m_shaderCachePath;

	TestNorthstar()
	{
		m_tempDir = std::filesystem::temp_directory_path();
		m_tempDir /= "RadeonProRenderTests";

		if (!std::filesystem::exists(m_tempDir)) {
			//std::filesystem::remove_all(m_tempDir);
			std::filesystem::create_directory(m_tempDir);
		}
		m_shaderCachePath = m_tempDir / "cache";

		std::cout << "Temporary directory: \t" << m_tempDir <<  "\n";
	}

    void SetUp()
    {
		m_plugin = std::make_unique<Plugin>(Plugin::Type::Northstar);
    }

    void TearDown()
    {
    	m_plugin.reset();
    }


	int GetCreationFlags(const gpu_list_t& devices)
	{
		rpr_creation_flags flags = 0;

		std::for_each(devices.begin(), devices.end(),
			[&flags](const gpu_list_t::value_type& p) {
				if (p.first != RPR_CREATION_FLAGS_ENABLE_CPU)
					flags |= p.first;
		});

		if (flags == 0)
			flags = RPR_CREATION_FLAGS_ENABLE_CPU;

		return flags;
	}
};

TEST_F(TestNorthstar, context_creation)
{
	ASSERT_TRUE(m_plugin);

	auto gpus = getAvailableDevices(*m_plugin, "");
 	printAvailableDevices(gpus, std::cout);

	Context context(*m_plugin, m_shaderCachePath.string(), GetCreationFlags(gpus));
	EXPECT_TRUE(context.instance());
}

TEST_F(TestNorthstar, scene_creation)
{
	ASSERT_TRUE(m_plugin);
	ASSERT_TRUE(!m_shaderCachePath.empty());
	ASSERT_TRUE(!m_tempDir.empty());

	auto gpus = getAvailableDevices(*m_plugin, "");
	Context context(*m_plugin, m_shaderCachePath.string(), GetCreationFlags(gpus));

	Scene scene(context);
	context.setScene(scene);

	// camera
	Camera camera(context);
	camera.lookAt(
			0, 5, 10,
			0, 0, 0,
			0, 1, 0);
	scene.setCamera(camera);

	Shape cube(context,
			reinterpret_cast<rpr_float const*>(&cube_data[0]),                         24, sizeof(vertex),
			reinterpret_cast<rpr_float const*>(&cube_data[0] + sizeof(rpr_float) * 3), 24, sizeof(vertex),
			reinterpret_cast<rpr_float const*>(&cube_data[0] + sizeof(rpr_float) * 6), 24, sizeof(vertex),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			num_face_vertices, 12);

	cube.setTransform(rprf_math::translation(rprf_math::float3(-2, 1, 0)), true);
	scene.attachShape(cube);

	// light
	LightPoint pointLight(context);
	pointLight.setTransform(rprf_math::translation(rprf_math::float3(2, 10, 2)), true);
	pointLight.setRadianPower(150.0f, 150.0f, 150.0f);
	scene.attachLight(pointLight);

	// framebuffer
	FrameBuffer frameBuffer(context, 800, 600);
	FrameBuffer frameBufferResolved(frameBuffer.clone());

	context.setAOV(frameBuffer);
	context.setParameter1u(RPR_CONTEXT_ITERATIONS, 60);

	context.render();
	context.resolve(&frameBuffer, &frameBufferResolved, false);

	frameBufferResolved.saveToFile((m_tempDir / "scene_creation00.png").string());

	//------------------------------------------------------------------------------------------
	Shape plane(context,
			reinterpret_cast<rpr_float const*>(&plane_data[0]), 4, sizeof(vertex),
			reinterpret_cast<rpr_float const*>(&plane_data[0] + sizeof(rpr_float) * 3), 4, sizeof(vertex),
			reinterpret_cast<rpr_float const*>(&plane_data[0] + sizeof(rpr_float) * 6), 4, sizeof(vertex),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			num_face_vertices, 2);

	scene.attachShape(plane);

	Shape cubeInstance(cube);
	cubeInstance.setTransform(rprf_math::translation(rprf_math::float3(2, 1, -3)) * rprf_math::rotation_y(0.5), true);
	scene.attachShape(cubeInstance);

	MaterialSystem materialSystem(context);

	MaterialNode diffuse1(materialSystem, MaterialNodeType::Diffuse);
	diffuse1.setParameter4f(RPR_MATERIAL_INPUT_COLOR, 0.6f, 0.4f, 1.0f, 0.0f);
	cube.setMaterial(diffuse1);

	MaterialNode diffuse2(materialSystem, MaterialNodeType::Diffuse);
	diffuse1.setParameter4f(RPR_MATERIAL_INPUT_COLOR, 1.0f, 0.5f, 0.0f, 0.0f);
	cubeInstance.setMaterial(diffuse2);

	MaterialNode diffuse3(materialSystem, MaterialNodeType::Diffuse);
	diffuse1.setParameter4f(RPR_MATERIAL_INPUT_COLOR, 0.1f, 0.8f, 1.0f, 0.0f);
	plane.setMaterial(diffuse3);

	frameBuffer.clear();

	context.render();
	context.resolve(&frameBuffer, &frameBufferResolved, true);

	frameBufferResolved.saveToFile((m_tempDir / "scene_creation01.png").string());

}

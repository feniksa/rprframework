#include "rprf/Plugin.h"
#include "rprf/Context.h"
#include "rprf/FrameBuffer.h"
#include "rprf/Scene.h"
#include "rprf/Camera.h"
#include "rprf/Shape.h"
#include "rprf/LightPoint.h"
#include "rprf/LightEnvironment.h"
#include "rprf/ContextUtils.h"
#include "rprf/FrameBufferSysmem.h"
#include "rprf/MaterialSystem.h"
#include "rprf/MaterialNode.h"
#include "rprf/Image.h"

#include "math/mathutils.h"

#include "Environment.h" // <- generated by cmake
#include "StreamRedirector.h"
#include "CommonData.h"

#include <gtest/gtest.h>
#include <algorithm>
#include <filesystem>

using namespace rprf;
using namespace tests;


struct TestNorthstar : public ::testing::Test
{
	std::unique_ptr<Plugin> m_plugin;
	std::filesystem::path m_tempDir;
	std::filesystem::path m_shaderCachePath;

	TestNorthstar()
	{
		m_tempDir = std::filesystem::temp_directory_path();
		m_tempDir /= "RadeonProRenderTests";
        m_tempDir /= "Northstar";

		if (!std::filesystem::exists(m_tempDir)) {
			//std::filesystem::remove_all(m_tempDir);
			std::filesystem::create_directory(m_tempDir);
		}
		m_shaderCachePath = m_tempDir / "cache";

		std::cout << "Temporary directory: \t" << m_tempDir <<  "\n";
	}

    void SetUp()
    {
		m_plugin = std::make_unique<Plugin>(Plugin::Type::Northstar);
    }

    void TearDown()
    {
    	m_plugin.reset();
    }


	int GetCreationFlags(const gpu_list_t& devices)
	{
		rpr_creation_flags flags = 0;

		std::for_each(devices.begin(), devices.end(),
			[&flags](const gpu_list_t::value_type& p) {
				if (p.first != RPR_CREATION_FLAGS_ENABLE_CPU)
					flags |= p.first;
		});

		if (flags == 0)
			flags = RPR_CREATION_FLAGS_ENABLE_CPU;

		return flags;
	}
};

TEST_F(TestNorthstar, context_creation)
{
	ASSERT_TRUE(m_plugin);

	auto gpus = getAvailableDevices(*m_plugin, "");
 	printAvailableDevices(gpus, std::cout);

	Context context(*m_plugin, m_shaderCachePath, GetCreationFlags(gpus));
	EXPECT_TRUE(context.instance());
}

TEST_F(TestNorthstar, scene_creation)
{
	ASSERT_TRUE(m_plugin);
	ASSERT_TRUE(!m_shaderCachePath.empty());
	ASSERT_TRUE(!m_tempDir.empty());

	auto gpus = getAvailableDevices(*m_plugin, "");
	Context context(*m_plugin, m_shaderCachePath, GetCreationFlags(gpus));

	Scene scene(context);
	context.setScene(scene);

	// camera
	Camera camera(context);
	camera.lookAt(
			0, 5, 10,
			0, 0, 0,
			0, 1, 0);
	scene.setCamera(camera);

	Shape cube(context,
			reinterpret_cast<rpr_float const*>(&cube_data[0]), 24, sizeof(vertex),
			reinterpret_cast<rpr_float const*>((char*)&cube_data[0] + sizeof(rpr_float) * 3), 24, sizeof(vertex),
			reinterpret_cast<rpr_float const*>((char*)&cube_data[0] + sizeof(rpr_float) * 6), 24, sizeof(vertex),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			num_face_vertices, 12);

	cube.setTransform(rprf_math::translation(rprf_math::float3(-2, 1, 0)), true);
	scene.attachShape(cube);

	// light
	LightPoint pointLight(context);
	pointLight.setTransform(rprf_math::translation(rprf_math::float3(2, 10, 2)), true);
	pointLight.setRadianPower(150.0f, 150.0f, 150.0f);
	scene.attachLight(pointLight);

	// framebuffer
	FrameBuffer frameBuffer(context, 800, 600);
	FrameBuffer frameBufferResolved(frameBuffer.clone());

	context.setAOV(frameBuffer);
	context.setParameter1u(ContextInputType::Iterations, 60);

	context.render();
	context.resolve(&frameBuffer, &frameBufferResolved, false);

	frameBufferResolved.saveToFile(m_tempDir / "scene_creation00.png");

	//------------------------------------------------------------------------------------------
	Shape plane(context,
			reinterpret_cast<rpr_float const*>(&plane_data[0]), 4, sizeof(vertex),
			reinterpret_cast<rpr_float const*>((char*)&plane_data[0] + sizeof(rpr_float) * 3), 4, sizeof(vertex),
			reinterpret_cast<rpr_float const*>((char*)&plane_data[0] + sizeof(rpr_float) * 6), 4, sizeof(vertex),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			num_face_vertices, 2);

	scene.attachShape(plane);

	Shape cubeInstance(cube);
	cubeInstance.setTransform(
		rprf_math::translation(rprf_math::float3(2, 1, -3)) *
		rprf_math::rotation_y(0.5), true);
	scene.attachShape(cubeInstance);

	MaterialSystem materialSystem(context);

	MaterialNode diffuse1(materialSystem, MaterialNodeType::Diffuse);
	diffuse1.setParameter4f(MaterialInputType::Color, 0.6f, 0.4f, 1.0f, 0.0f);
	cube.setMaterial(diffuse1);

	MaterialNode diffuse2(materialSystem, MaterialNodeType::Diffuse);
	diffuse2.setParameter4f(MaterialInputType::Color, 1.0f, 0.5f, 0.0f, 0.0f);
	cubeInstance.setMaterial(diffuse2);

	MaterialNode diffuse3(materialSystem, MaterialNodeType::Diffuse);
	diffuse3.setParameter4f(MaterialInputType::Color, 0.1f, 0.8f, 1.0f, 0.0f);
	plane.setMaterial(diffuse3);

	frameBuffer.clear();

	context.render();
	context.resolve(&frameBuffer, &frameBufferResolved, true);

	frameBufferResolved.saveToFile((m_tempDir / "scene_creation01.png").string());

	// add image
	const Image image1(context, CurrentWorkingDirectory / "Resources/Textures/lead_rusted_Base_Color.jpg");

	MaterialNode imageMaterial1(materialSystem, MaterialNodeType::ImageTexture);
	imageMaterial1.setParameterImage(MaterialInputType::Data, image1);

	MaterialNode diffuse4(materialSystem, MaterialNodeType::Diffuse);
	diffuse4.setParameterNode(MaterialInputType::Color, imageMaterial1);

	cube.setMaterial(diffuse4);

	// add image2
	const Image image2(context, CurrentWorkingDirectory / "Resources/Textures/amd.png");

	MaterialNode imageMaterial2(materialSystem, MaterialNodeType::ImageTexture);
	imageMaterial2.setParameterImage(MaterialInputType::Data, image2);

	MaterialNode diffuse5(materialSystem, MaterialNodeType::Diffuse);
	diffuse5.setParameterNode(MaterialInputType::Color, imageMaterial2);


	// create a Lookup material and define it as a "UV Lookup" meaning the output of this material is the UV from the shape.
	// Lookup nodes are useful to create procedural materials.
	// UV-Lookup are often used to scale textures on shapes.
	MaterialNode uv_node(materialSystem, MaterialNodeType::InputLookup);
	uv_node.setParameter1u(MaterialInputType::Value, RPR_MATERIAL_NODE_LOOKUP_UV);


	// adjust the texture scale by multiplying the the UV by a constant
	MaterialNode uv_scaled_node(materialSystem, MaterialNodeType::Arithmetic);
	uv_scaled_node.setParameter1u(MaterialInputType::Op, RPR_MATERIAL_NODE_OP_MUL);
	uv_scaled_node.setParameterNode(MaterialInputType::Color0, uv_node);
	uv_scaled_node.setParameter4f(MaterialInputType::Color1, 4.0f, 12.0f, 0.0f, 0.0f);


	// apply this modified UV to the image material.
	imageMaterial2.setParameterNode(MaterialInputType::Uv, uv_scaled_node);
	plane.setMaterial(diffuse5);

	// create a simple reflection material and apply it on the cube_instance
	MaterialNode reflection1(materialSystem, MaterialNodeType::Reflection);
	reflection1.setParameter4f(MaterialInputType::Color,1.0f, 1.0f, 1.0f, 0.0f);
	cubeInstance.setMaterial(reflection1);

	scene.detachLight(pointLight);

	// Create environment light
	LightEnvironment lightEnvironemt(context);
	Image imageEnvironment(context, CurrentWorkingDirectory / "Resources/Textures/turning_area_4k.hdr");
	lightEnvironemt.setImage(imageEnvironment);
	lightEnvironemt.setIntensityScale(0.8f);

	scene.attachLight(lightEnvironemt);
	camera.lookAt(0, 4, 10, 0, 1, 0, 0, 1, 0);
	context.setParameter1f(ContextInputType::DisplayGamma, 2.2f);

	frameBuffer.clear();
	context.render();
	context.resolve(&frameBuffer, &frameBufferResolved, false);

	frameBufferResolved.saveToFile(m_tempDir / "scene_creation02.png");

	// ----------------------------------------------------------------------
	// animate scene
	// ----------------------------------------------------------------------
	camera.lookAt(0.0f, 4.0f, 9.0f,
		0.0f, 0.0f, 0.0f,
		0.0f, 1.0f, 0.0f);

	cubeInstance.setTransform(
		rprf_math::translation(rprf_math::float3(1.0f, 1.0f, -3.0f))*
		rprf_math::rotation_y(0.7f) *
		rprf_math::scale(rprf_math::float3(1.0f, 1.0f, 4.0f)), true
	);

	// change scaling of the AMD logo on the floor
	uv_scaled_node.setParameter4f(MaterialInputType::Color1, 10.0f, 20.0f, 0.0f, 0.0f);

	// replace the material on cuve by an emissive one.
	MaterialNode emissive(materialSystem, MaterialNodeType::Emissive);
	emissive.setParameter4f(MaterialInputType::Color, 6.0f, 3.0f, 0.0f, 0.0f);

	cube.setMaterial(emissive);
	cube.setTransform(
		rprf_math::translation(rprf_math::float3(-2.0f, 0.7f, 0.0f))*
		rprf_math::rotation_y(0.0f) *
		rprf_math::scale(rprf_math::float3(0.5f, 0.5f, 0.5f)), true
	);

	cube.setVisibilityType(ShapeVisibilityType::Shadow, false);

	// remove the Env light, and use the point light again.
	scene.attachLight(pointLight);
	scene.detachLight(lightEnvironemt);

	context.setParameter1u(ContextInputType::Iterations, 120);

	frameBuffer.clear();

	context.render();
	context.resolve(&frameBuffer, &frameBufferResolved, false);
	frameBufferResolved.saveToFile(m_tempDir / "scene_creation03.png");
}

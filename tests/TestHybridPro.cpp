#include "rprf/Plugin.h"
#include "rprf/Context.h"
#include "rprf/FrameBuffer.h"
#include "rprf/Scene.h"
#include "rprf/Camera.h"
#include "rprf/Shape.h"
#include "rprf/LightPoint.h"
#include "rprf/LightEnvironment.h"
#include "rprf/ContextUtils.h"
#include "rprf/MaterialSystem.h"
#include "rprf/MaterialNode.h"
#include "rprf/Image.h"
#include "rprf/FrameBufferSysmem.h"

#include "rprf/math/mathutils.h"

#include "Environment.h" // <- generated by cmake
#include "StreamRedirect.h"
#include "CommonData.h"

#include <gtest/gtest.h>
#include <algorithm>
#include <filesystem>

using namespace rprf;
using namespace tests;


struct TestHybridPro : public ::testing::Test
{
	std::unique_ptr<Plugin> m_plugin;
	std::filesystem::path m_tempDir;
	std::filesystem::path m_shaderCachePath;

    const bool enableCPU = false;

    gpu_list_t gpus;

	TestHybridPro()
	{
		m_tempDir = std::filesystem::temp_directory_path();
		m_tempDir /= "RadeonProRenderTests";
        if (!std::filesystem::exists(m_tempDir)) {
            //std::filesystem::remove_all(m_tempDir);
            std::filesystem::create_directory(m_tempDir);
        }

        m_tempDir /= "HybridPro";
		if (!std::filesystem::exists(m_tempDir)) {
			std::filesystem::create_directory(m_tempDir);
		}
		m_shaderCachePath = m_tempDir / "cache";

        m_plugin = std::make_unique<Plugin>(Plugin::Type::HybridPro);
        gpus = getAvailableDevices(*m_plugin, "", "");
	}

    void SetUp() override
    {
    }

    void TearDown() override
    {
        if (!::testing::Test::HasFailure()) {
            std::filesystem::remove_all(m_tempDir);
        } else {
            std::cout << "Temporary directory: \t" << m_tempDir <<  "\n";
            printAvailableDevices(gpus, std::cout);
        }

        //m_plugin.reset();
    }


	int GetCreationFlags(const gpu_list_t& devices)
	{
		rpr_creation_flags flags = 0;

        for (size_t i = 0; i < devices.size(); ++i) {
            unsigned int creationFlag = devices[i].first;

            flags |= creationFlag;
        }

		if (flags == 0 || enableCPU)
			flags |= RPR_CREATION_FLAGS_ENABLE_CPU;

		return flags;
	}
};

TEST_F(TestHybridPro, context_creation)
{
	ASSERT_TRUE(m_plugin);

    auto gpus = getAvailableDevices(*m_plugin, "", "");
 	//printAvailableDevices(gpus, std::cout);

    int creationFlags = GetCreationFlags(gpus);
	Context context(*m_plugin, m_shaderCachePath, "", creationFlags);
	EXPECT_TRUE(context.instance());

    EXPECT_EQ(context.createFlags(), creationFlags);
}

TEST_F(TestHybridPro, framebuffer_params)
{
    int creationFlags = GetCreationFlags(gpus);
    Context context(*m_plugin, m_shaderCachePath, "", creationFlags);

    FrameBuffer frameBuffer(context, 800, 600);

    // check framebuffer
    const auto format = frameBuffer.getFormat();
    EXPECT_EQ(format.numComponents, 4);
    EXPECT_EQ(format.type, ComponentsType::Float32);

    const auto desc = frameBuffer.getDesc();
    EXPECT_EQ(desc.width, 800);
    EXPECT_EQ(desc.height, 600);
}


TEST_F(TestHybridPro, camera_params)
{
    int creationFlags = GetCreationFlags(gpus);
    Context context(*m_plugin, m_shaderCachePath, "", creationFlags);

    const auto transform = rprf_math::matrix(
            1.0f, 2.0f, 3.0f, 4.0f,
            5.0f, 6.0f, 7.0f, 8.0f,
            9.0f, 10.0f, 11.0f, 12.0f,
            13.0f, 14.0f, 15.0f, 16.0f
    );

    Camera camera(context);

    camera.setTransform(transform, false);

    const rprf_math::matrix m = camera.getTransform();
    EXPECT_FLOAT_EQ(m.m00, 1.0f);
    EXPECT_FLOAT_EQ(m.m01, 2.0f);
    EXPECT_FLOAT_EQ(m.m02, 3.0f);
    EXPECT_FLOAT_EQ(m.m03, 4.0f);
    EXPECT_FLOAT_EQ(m.m10, 5.0f);
    EXPECT_FLOAT_EQ(m.m11, 6.0f);
    EXPECT_FLOAT_EQ(m.m12, 7.0f);
    EXPECT_FLOAT_EQ(m.m13, 8.0f);
    EXPECT_FLOAT_EQ(m.m20, 9.0f);
    EXPECT_FLOAT_EQ(m.m21, 10.0f);
    EXPECT_FLOAT_EQ(m.m22, 11.0f);
    EXPECT_FLOAT_EQ(m.m23, 12.0f);
    EXPECT_FLOAT_EQ(m.m30, 13.0f);
    EXPECT_FLOAT_EQ(m.m31, 14.0f);
    EXPECT_FLOAT_EQ(m.m32, 15.0f);
    EXPECT_FLOAT_EQ(m.m33, 16.0f);
}

TEST_F(TestHybridPro, material_node_params)
{
    Context context(*m_plugin, m_shaderCachePath, "", GetCreationFlags(gpus));

    Scene scene(context);
    context.setScene(scene);

    MaterialSystem materialSystem(context);

    // replace the material on cuve by an emissive one.
    MaterialNode emissive(materialSystem, MaterialNodeType::Emissive);
    emissive.setParameter4f(MaterialInputType::Color, 6.0f, 3.0f, 0.0f, 0.0f);
    emissive.setName("emissive_name");

    // test for Material Get
    const auto pins = emissive.readMaterialParameters();
    /*std::for_each(pins.begin(), pins.end(), [](const MaterialNodeInput& pin) {
        std::cout << pin << "\n";
    });*/

    EXPECT_TRUE(hasParameter(pins, rprf::MaterialInputType::Color));
    EXPECT_FALSE(hasParameter(pins, rprf::MaterialInputType::Highlight2));
    float r, g, b, a;
    std::tie(r, g, b, a) = getFloat4f(pins, rprf::MaterialInputType::Color);
    EXPECT_FLOAT_EQ(6.0f, r);
    EXPECT_FLOAT_EQ(3.0f, g);
    EXPECT_FLOAT_EQ(0.0f, b);
    EXPECT_FLOAT_EQ(0.0f, a);

    // test node get
    MaterialNode someNode(materialSystem, MaterialNodeType::Emissive);
    someNode.setParameterNode(MaterialInputType::Color, emissive);

    const auto pins2 = someNode.readMaterialParameters();
    EXPECT_TRUE(hasParameter(pins2, MaterialInputType::Color));

    void* emissiveAddress = &emissive;
    const MaterialNode* node = getNode(pins2, MaterialInputType::Color);

    EXPECT_EQ(node, emissiveAddress);
    EXPECT_EQ(node->name(), emissive.name());
}

TEST_F(TestHybridPro, material_node_list)
{
    Context context(*m_plugin, m_shaderCachePath, "", GetCreationFlags(gpus));

    Scene scene(context);
    context.setScene(scene);

    Shape plane(context,
                reinterpret_cast<rpr_float const*>(&plane_data[0]), 4, sizeof(vertex),
                reinterpret_cast<rpr_float const*>((char*)&plane_data[0] + sizeof(rpr_float) * 3), 4, sizeof(vertex),
                reinterpret_cast<rpr_float const*>((char*)&plane_data[0] + sizeof(rpr_float) * 6), 4, sizeof(vertex),
                static_cast<rpr_int const*>(indices), sizeof(rpr_int),
                static_cast<rpr_int const*>(indices), sizeof(rpr_int),
                static_cast<rpr_int const*>(indices), sizeof(rpr_int),
                num_face_vertices, 2);

    scene.attachShape(plane);

    MaterialSystem materialSystem(context);

    const std::string materialName = "_emissive01";
    // replace the material on cuve by an emissive one.
    MaterialNode emissive(materialSystem, MaterialNodeType::Emissive);
    emissive.setParameter4f(MaterialInputType::Color, 6.0f, 3.0f, 0.0f, 0.0f);
    emissive.setName(materialName.c_str());

    MaterialNode* originalAddress = &emissive;

    EXPECT_EQ(emissive.name(), materialName);

    plane.setMaterial(emissive);

    auto nodeList = materialSystem.getNodeList();
    EXPECT_EQ(nodeList.size(), 1);

    MaterialNode* node = nodeList[0];
    EXPECT_EQ(node, originalAddress);
    EXPECT_EQ(node->name(), materialName);

    // same with iterator
    for (auto iter = nodeList.begin(); iter != nodeList.end(); ++iter) {
        EXPECT_EQ(iter->name(), materialName);
    }

    const auto nodeList2 = materialSystem.getNodeList();
    // same with const iterator
    for (auto iter = nodeList2.begin(); iter != nodeList2.end(); ++iter) {
        EXPECT_EQ(iter->name(), materialName);
    }

    // add second material
    const std::string materialName2 = "diffuse";
    MaterialNode diffuse(materialSystem, MaterialNodeType::Diffuse);
    diffuse.setParameter4f(MaterialInputType::Color, 1.0f, 2.0f, 3.0f, 0.0f);
    diffuse.setName(materialName2.c_str());
    EXPECT_EQ(diffuse.name(), materialName2);

}

TEST_F(TestHybridPro, scene_creation)
{
	ASSERT_TRUE(m_plugin);
	ASSERT_TRUE(!m_shaderCachePath.empty());
	ASSERT_TRUE(!m_tempDir.empty());

	Context context(*m_plugin, m_shaderCachePath, "", GetCreationFlags(gpus));

	Scene scene(context);
	context.setScene(scene);

	// camera
	Camera camera(context);
	camera.lookAt(
			0, 5, 10,
			0, 0, 0,
			0, 1, 0);
	scene.setCamera(camera);

	Shape cube(context,
			reinterpret_cast<rpr_float const*>(&cube_data[0]), 24, sizeof(vertex),
			reinterpret_cast<rpr_float const*>((char*)&cube_data[0] + sizeof(rpr_float) * 3), 24, sizeof(vertex),
			reinterpret_cast<rpr_float const*>((char*)&cube_data[0] + sizeof(rpr_float) * 6), 24, sizeof(vertex),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			num_face_vertices, 12);

	cube.setTransform(rprf_math::translation(rprf_math::float3(-2, 1, 0)), true);
	scene.attachShape(cube);

	// light
	LightPoint pointLight(context);
	pointLight.setTransform(rprf_math::translation(rprf_math::float3(2, 10, 2)), true);
	pointLight.setRadianPower(150.0f, 150.0f, 150.0f);
	scene.attachLight(pointLight);

	// framebuffer
	FrameBuffer frameBuffer(context, 800, 600);
	FrameBuffer frameBufferResolved(frameBuffer.clone());

	context.setAOV(frameBuffer);
	context.setParameter1u(ContextInputType::Iterations, 60);

	context.render();
	context.resolve(&frameBuffer, &frameBufferResolved, false);

	frameBufferResolved.saveToFile(m_tempDir / "scene_creation00.png");

	//------------------------------------------------------------------------------------------
	Shape plane(context,
			reinterpret_cast<rpr_float const*>(&plane_data[0]), 4, sizeof(vertex),
			reinterpret_cast<rpr_float const*>((char*)&plane_data[0] + sizeof(rpr_float) * 3), 4, sizeof(vertex),
			reinterpret_cast<rpr_float const*>((char*)&plane_data[0] + sizeof(rpr_float) * 6), 4, sizeof(vertex),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			static_cast<rpr_int const*>(indices), sizeof(rpr_int),
			num_face_vertices, 2);

	scene.attachShape(plane);

	Shape cubeInstance(cube);
	cubeInstance.setTransform(
		rprf_math::translation(rprf_math::float3(2, 1, -3)) *
		rprf_math::rotation_y(0.5), true);
	scene.attachShape(cubeInstance);

	MaterialSystem materialSystem(context);

	MaterialNode diffuse1(materialSystem, MaterialNodeType::Diffuse);
	diffuse1.setParameter4f(MaterialInputType::Color, 0.6f, 0.4f, 1.0f, 0.0f);
	cube.setMaterial(diffuse1);

	MaterialNode diffuse2(materialSystem, MaterialNodeType::Diffuse);
	diffuse2.setParameter4f(MaterialInputType::Color, 1.0f, 0.5f, 0.0f, 0.0f);
	cubeInstance.setMaterial(diffuse2);

	MaterialNode diffuse3(materialSystem, MaterialNodeType::Diffuse);
	diffuse3.setParameter4f(MaterialInputType::Color, 0.1f, 0.8f, 1.0f, 0.0f);
	plane.setMaterial(diffuse3);

	frameBuffer.clear();

	context.render();
	context.resolve(&frameBuffer, &frameBufferResolved, true);

	frameBufferResolved.saveToFile((m_tempDir / "scene_creation01.png").string());

	// add image
	const Image image1(context, CurrentWorkingDirectory / "Resources/Textures/lead_rusted_Base_Color.jpg");

	MaterialNode imageMaterial1(materialSystem, MaterialNodeType::ImageTexture);
	imageMaterial1.setParameterImage(MaterialInputType::Data, image1);

	MaterialNode diffuse4(materialSystem, MaterialNodeType::Diffuse);
	diffuse4.setParameterNode(MaterialInputType::Color, imageMaterial1);

	cube.setMaterial(diffuse4);

	// add image2
	const Image image2(context, CurrentWorkingDirectory / "Resources/Textures/amd.png");

	MaterialNode imageMaterial2(materialSystem, MaterialNodeType::ImageTexture);
	imageMaterial2.setParameterImage(MaterialInputType::Data, image2);

	MaterialNode diffuse5(materialSystem, MaterialNodeType::Diffuse);
	diffuse5.setParameterNode(MaterialInputType::Color, imageMaterial2);


	// allocate a Lookup material and define it as a "UV Lookup" meaning the output of this material is the UV from the shape.
	// Lookup nodes are useful to allocate procedural materials.
	// UV-Lookup are often used to scale textures on shapes.
	MaterialNode uv_node(materialSystem, MaterialNodeType::InputLookup);
	uv_node.setParameter1u(MaterialInputType::Value, RPR_MATERIAL_NODE_LOOKUP_UV);


	// adjust the texture scale by multiplying the the UV by a constant
	MaterialNode uv_scaled_node(materialSystem, MaterialNodeType::Arithmetic);
	uv_scaled_node.setParameter1u(MaterialInputType::Op, RPR_MATERIAL_NODE_OP_MUL);
	uv_scaled_node.setParameterNode(MaterialInputType::Color0, uv_node);
	uv_scaled_node.setParameter4f(MaterialInputType::Color1, 4.0f, 12.0f, 0.0f, 0.0f);


	// apply this modified UV to the image material.
	imageMaterial2.setParameterNode(MaterialInputType::Uv, uv_scaled_node);
	plane.setMaterial(diffuse5);

	// allocate a simple reflection material and apply it on the cube_instance
	MaterialNode reflection1(materialSystem, MaterialNodeType::Reflection);
	reflection1.setParameter4f(MaterialInputType::Color,1.0f, 1.0f, 1.0f, 0.0f);
	cubeInstance.setMaterial(reflection1);

	scene.detachLight(pointLight);

	// Create environment light
	LightEnvironment lightEnvironemt(context);
	Image imageEnvironment(context, CurrentWorkingDirectory / "Resources/Textures/turning_area_4k.hdr");
	lightEnvironemt.setImage(imageEnvironment);
	lightEnvironemt.setIntensityScale(0.8f);

	scene.attachLight(lightEnvironemt);
	camera.lookAt(0, 4, 10, 0, 1, 0, 0, 1, 0);
	context.setParameter1f(ContextInputType::DisplayGamma, 2.2f);

	frameBuffer.clear();
	context.render();
	context.resolve(&frameBuffer, &frameBufferResolved, false);

	frameBufferResolved.saveToFile(m_tempDir / "scene_creation02.png");

	// ----------------------------------------------------------------------
	// animate scene
	// ----------------------------------------------------------------------
	camera.lookAt(0.0f, 4.0f, 9.0f,
		0.0f, 0.0f, 0.0f,
		0.0f, 1.0f, 0.0f);

	cubeInstance.setTransform(
		rprf_math::translation(rprf_math::float3(1.0f, 1.0f, -3.0f))*
		rprf_math::rotation_y(0.7f) *
		rprf_math::scale(rprf_math::float3(1.0f, 1.0f, 4.0f)), true
	);

	// change scaling of the AMD logo on the floor
	uv_scaled_node.setParameter4f(MaterialInputType::Color1, 10.0f, 20.0f, 0.0f, 0.0f);

	// replace the material on cuve by an emissive one.
	MaterialNode emissive(materialSystem, MaterialNodeType::Emissive);
	emissive.setParameter4f(MaterialInputType::Color, 6.0f, 3.0f, 0.0f, 0.0f);

	cube.setMaterial(emissive);
	cube.setTransform(
		rprf_math::translation(rprf_math::float3(-2.0f, 0.7f, 0.0f))*
		rprf_math::rotation_y(0.0f) *
		rprf_math::scale(rprf_math::float3(0.5f, 0.5f, 0.5f)), true
	);

	cube.setVisibilityType(ShapeVisibilityType::Shadow, false);

	// remove the Env light, and use the point light again.
	scene.attachLight(pointLight);
	scene.detachLight(lightEnvironemt);

	context.setParameter1u(ContextInputType::Iterations, 120);

	frameBuffer.clear();

	context.render();
	context.resolve(&frameBuffer, &frameBufferResolved, false);
	frameBufferResolved.saveToFile(m_tempDir / "scene_creation03.png");
}

TEST_F(TestHybridPro, framebuffer_info)
{
    Context context(*m_plugin, m_shaderCachePath, "", GetCreationFlags(gpus));

    Scene scene(context);
    context.setScene(scene);

    // camera
    Camera camera(context);
    camera.lookAt(
            0, 5, 10,
            0, 0, 0,
            0, 1, 0);
    scene.setCamera(camera);

    Shape cube(context,
               reinterpret_cast<rpr_float const*>(&cube_data[0]), 24, sizeof(vertex),
               reinterpret_cast<rpr_float const*>((char*)&cube_data[0] + sizeof(rpr_float) * 3), 24, sizeof(vertex),
               reinterpret_cast<rpr_float const*>((char*)&cube_data[0] + sizeof(rpr_float) * 6), 24, sizeof(vertex),
               static_cast<rpr_int const*>(indices), sizeof(rpr_int),
               static_cast<rpr_int const*>(indices), sizeof(rpr_int),
               static_cast<rpr_int const*>(indices), sizeof(rpr_int),
               num_face_vertices, 12);

    cube.setTransform(rprf_math::translation(rprf_math::float3(-2, 1, 0)), true);
    scene.attachShape(cube);

    // light
    LightPoint pointLight(context);
    pointLight.setTransform(rprf_math::translation(rprf_math::float3(2, 10, 2)), true);
    pointLight.setRadianPower(150.0f, 150.0f, 150.0f);
    scene.attachLight(pointLight);

    // framebuffer
    FrameBuffer frameBuffer(context, 800, 600);
    FrameBuffer frameBufferResolved(frameBuffer.clone());

    context.setAOV(frameBuffer);
    context.setParameter1u(ContextInputType::Iterations, 60);

    context.render();
    context.resolve(&frameBuffer, &frameBufferResolved, false);

    frameBufferResolved.saveToFile(m_tempDir / "scene_creation00.png");

    //------------------------------------------------------------------------------------------
    Shape plane(context,
                reinterpret_cast<rpr_float const*>(&plane_data[0]), 4, sizeof(vertex),
                reinterpret_cast<rpr_float const*>((char*)&plane_data[0] + sizeof(rpr_float) * 3), 4, sizeof(vertex),
                reinterpret_cast<rpr_float const*>((char*)&plane_data[0] + sizeof(rpr_float) * 6), 4, sizeof(vertex),
                static_cast<rpr_int const*>(indices), sizeof(rpr_int),
                static_cast<rpr_int const*>(indices), sizeof(rpr_int),
                static_cast<rpr_int const*>(indices), sizeof(rpr_int),
                num_face_vertices, 2);

    scene.attachShape(plane);

    Shape cubeInstance(cube);
    cubeInstance.setTransform(
            rprf_math::translation(rprf_math::float3(2, 1, -3)) *
            rprf_math::rotation_y(0.5), true);
    scene.attachShape(cubeInstance);

    MaterialSystem materialSystem(context);

    MaterialNode diffuse1(materialSystem, MaterialNodeType::Diffuse);
    diffuse1.setParameter4f(MaterialInputType::Color, 0.6f, 0.4f, 1.0f, 0.0f);
    cube.setMaterial(diffuse1);

    MaterialNode diffuse2(materialSystem, MaterialNodeType::Diffuse);
    diffuse2.setParameter4f(MaterialInputType::Color, 1.0f, 0.5f, 0.0f, 0.0f);
    cubeInstance.setMaterial(diffuse2);

    MaterialNode diffuse3(materialSystem, MaterialNodeType::Diffuse);
    diffuse3.setParameter4f(MaterialInputType::Color, 0.1f, 0.8f, 1.0f, 0.0f);
    plane.setMaterial(diffuse3);

    frameBuffer.clear();

    context.render();
    context.resolve(&frameBuffer, &frameBufferResolved, true);
    frameBufferResolved.saveToFile(m_tempDir / "scene_creation01.png");

    FrameBufferSysmem frameBufferSysmem(frameBufferResolved);
    frameBufferSysmem.update();

    bool writeStatus = frameBufferSysmem.saveToFile(m_tempDir / "scene_creation02.png");
    EXPECT_TRUE(writeStatus);

    /*MemoryImage image1(m_tempDir / "scene_creation01.png");
    MemoryImage image2(m_tempDir / "scene_creation02.png");
    EXPECT_TRUE(image1 == image2);*/
}
